[Skip to content](https://github.com/syhien/NJU-Algorithm-Design-and-Analysis-reviewing-material/blob/main/README.md#start-of-content)



Product [Team](https://github.com/team)[Enterprise](https://github.com/enterprise)Explore [Marketplace](https://github.com/marketplace)Pricing 



[Sign in](https://github.com/login?return_to=https%3A%2F%2Fgithub.com%2Fsyhien%2FNJU-Algorithm-Design-and-Analysis-reviewing-material)

[Sign up](https://github.com/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%2F&source=header-repo&source_repo=syhien%2FNJU-Algorithm-Design-and-Analysis-reviewing-material)



[syhien](https://github.com/syhien)/**[NJU-Algorithm-Design-and-Analysis-reviewing-material](https://github.com/syhien/NJU-Algorithm-Design-and-Analysis-reviewing-material)**Public

- [Notifications](https://github.com/login?return_to=%2Fsyhien%2FNJU-Algorithm-Design-and-Analysis-reviewing-material)
- [Fork 2](https://github.com/login?return_to=%2Fsyhien%2FNJU-Algorithm-Design-and-Analysis-reviewing-material)
- [ Star 2](https://github.com/login?return_to=%2Fsyhien%2FNJU-Algorithm-Design-and-Analysis-reviewing-material)

- [Code](https://github.com/syhien/NJU-Algorithm-Design-and-Analysis-reviewing-material)
- [Issues](https://github.com/syhien/NJU-Algorithm-Design-and-Analysis-reviewing-material/issues)
- [Pull requests](https://github.com/syhien/NJU-Algorithm-Design-and-Analysis-reviewing-material/pulls)
- [Actions](https://github.com/syhien/NJU-Algorithm-Design-and-Analysis-reviewing-material/actions)
- [Projects](https://github.com/syhien/NJU-Algorithm-Design-and-Analysis-reviewing-material/projects?type=beta)
- [Wiki](https://github.com/syhien/NJU-Algorithm-Design-and-Analysis-reviewing-material/wiki)
- [Security](https://github.com/syhien/NJU-Algorithm-Design-and-Analysis-reviewing-material/security)
- [Insights](https://github.com/syhien/NJU-Algorithm-Design-and-Analysis-reviewing-material/pulse)

<details data-view-component="true" class="details-overlay details-reset position-relative" style="box-sizing: border-box; display: block; position: relative !important;"><summary role="button" data-view-component="true" style="box-sizing: border-box; display: list-item; cursor: pointer; transition: color 80ms cubic-bezier(0.33, 1, 0.68, 1) 0s, background-color, box-shadow, border-color; list-style: none;"><div class="UnderlineNav-item mr-0 border-0" style="box-sizing: border-box; position: relative; display: flex; padding: 0px 8px; font-size: 14px; line-height: 30px; color: var(--color-fg-default); text-align: center; white-space: nowrap; cursor: pointer; background-color: transparent; border: 0px !important; border-radius: 6px; align-items: center; margin-right: 0px !important;"><svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true" class="octicon octicon-kebab-horizontal"><path d="M8 9a1.5 1.5 0 100-3 1.5 1.5 0 000 3zM1.5 9a1.5 1.5 0 100-3 1.5 1.5 0 000 3zm13 0a1.5 1.5 0 100-3 1.5 1.5 0 000 3z"></path></svg><span class="sr-only" style="box-sizing: border-box; position: absolute; width: 1px; height: 1px; padding: 0px; overflow: hidden; clip: rect(0px, 0px, 0px, 0px); overflow-wrap: normal; border: 0px;"></span></div></summary></details>

 main 

## [NJU-Algorithm-Design-and-Analysis-reviewing-material](https://github.com/syhien/NJU-Algorithm-Design-and-Analysis-reviewing-material)/**README.md**

[Go to file](https://github.com/syhien/NJU-Algorithm-Design-and-Analysis-reviewing-material/find/main)

<details id="blob-more-options-details" data-view-component="true" class="details-overlay details-reset position-relative" style="box-sizing: border-box; display: block; position: relative !important;"><summary role="button" data-view-component="true" class="btn" style="box-sizing: border-box; display: inline-block; cursor: pointer; transition: color 80ms cubic-bezier(0.33, 1, 0.68, 1) 0s, background-color, box-shadow, border-color; position: relative; padding: 5px 16px; font-size: 14px; font-weight: 500; line-height: 20px; white-space: nowrap; vertical-align: middle; user-select: none; border-width: 1px; border-style: solid; border-color: var(--color-btn-border); border-image: initial; border-radius: 6px; appearance: none; color: var(--color-btn-text); background-color: var(--color-btn-bg); box-shadow: var(--color-btn-shadow),var(--color-btn-inset-shadow); list-style: none;"><svg aria-label="More options" role="img" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true" class="octicon octicon-kebab-horizontal"><path d="M8 9a1.5 1.5 0 100-3 1.5 1.5 0 000 3zM1.5 9a1.5 1.5 0 100-3 1.5 1.5 0 000 3zm13 0a1.5 1.5 0 100-3 1.5 1.5 0 000 3z"></path></svg></summary></details>

[![@syhien](https://avatars.githubusercontent.com/u/32589592?s=48&v=4)](https://github.com/syhien)

[syhien](https://github.com/syhien) [增加课本没提但常见的 分组背包 相关](https://github.com/syhien/NJU-Algorithm-Design-and-Analysis-reviewing-material/commit/2a6feec634391e683a0ed7a1140c58387c1c8876)



Latest commit [2a6feec](https://github.com/syhien/NJU-Algorithm-Design-and-Analysis-reviewing-material/commit/2a6feec634391e683a0ed7a1140c58387c1c8876) 25 days ago[ **History**](https://github.com/syhien/NJU-Algorithm-Design-and-Analysis-reviewing-material/commits/main/README.md)

 **1** contributor

<details data-target="readme-toc.trigger" data-menu-hydro-click="{&quot;event_type&quot;:&quot;repository_toc_menu.click&quot;,&quot;payload&quot;:{&quot;target&quot;:&quot;trigger&quot;,&quot;repository_id&quot;:384603440,&quot;originating_url&quot;:&quot;https://github.com/syhien/NJU-Algorithm-Design-and-Analysis-reviewing-material/blob/main/README.md&quot;,&quot;user_id&quot;:null}}" data-menu-hydro-click-hmac="6a9fc3eb91bb5b7830819e8d8324a3deb684ae51a01cd8f7dca802be66771f6e" class="dropdown details-reset details-overlay" style="box-sizing: border-box; display: block; position: relative;"><summary class="btn btn-octicon m-0 mr-2 p-2" aria-haspopup="menu" aria-label="Table of Contents" role="button" style="box-sizing: border-box; display: inline-block; cursor: pointer; transition: color 80ms cubic-bezier(0.33, 1, 0.68, 1) 0s, background-color, box-shadow, border-color; position: relative; padding: 8px !important; font-size: 14px; font-weight: 500; line-height: 1; white-space: nowrap; vertical-align: middle; user-select: none; border: 0px; border-radius: 6px; appearance: none; color: var(--color-fg-muted); background: transparent; box-shadow: none; margin: 0px 8px 0px 0px !important; list-style: none;"><svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true" class="octicon octicon-list-unordered"><path fill-rule="evenodd" d="M2 4a1 1 0 100-2 1 1 0 000 2zm3.75-1.5a.75.75 0 000 1.5h8.5a.75.75 0 000-1.5h-8.5zm0 5a.75.75 0 000 1.5h8.5a.75.75 0 000-1.5h-8.5zm0 5a.75.75 0 000 1.5h8.5a.75.75 0 000-1.5h-8.5zM3 8a1 1 0 11-2 0 1 1 0 012 0zm-1 6a1 1 0 100-2 1 1 0 000 2z"></path></svg></summary></details>

1173 lines (811 sloc) 31 KB



[Raw](https://github.com/syhien/NJU-Algorithm-Design-and-Analysis-reviewing-material/raw/main/README.md)[Blame](https://github.com/syhien/NJU-Algorithm-Design-and-Analysis-reviewing-material/blame/main/README.md)







# 算法设计与分析 期末

[TOC]

## 算法的抽象分析

### 证明正确性

肯定用**数学归纳法**

### 性能指标

最坏情况时间复杂度

平均情况时间复杂度：A(n)=∑I∈DnPr(I)⋅f(I)，I是输入，f(I)是该输入的具体时间复杂度

## 算法中的数学

### 渐进增长率

f(n)=O(g(n)) iff limn→∞f(n)g(n)=c<∞,c>0f(n)=o(g(n)) iff limn→∞f(n)g(n)=0

两个都说明了f(n)增长率不如g(n)，但o(g(n))强调f与g间存在实质性的差距（更不如g了） $$ f(n)=\Theta(g(n)) \text{ iff } \lim_{n\to \infty}\frac{f(n)}{g(n)} = c,0<c<\infty \ f(n)=\Theta(g(n)) \text{ iff } f(n)=O(g(n))\and f(n)=\Omega(g(n)) $$ 说明f和g同级 $$ f(n)=\Omega(g(n)) \text{ iff } \lim_{n\to \infty}\frac{f(n)}{g(n)}=c>0,c\text{可以为}\infty\ f(n)=\omega(g(n)) \text{ iff } \lim_{n\to \infty}\frac{f(n)}{g(n)}=\infty $$ 两个都说明了f(n)增长率优于g(n)，但ω(g(n))强调f与g间存在实质性的差距（更胜于g了）

### 求解分治与递归

#### 替换法

（期中考过）

利用数学归纳法，归纳证明T(n)的复杂度也小于等于cO(n)，c是某常数。

例如，求T(n)=2T(n/2)+n，猜测为O(nlog⁡n)，步骤如下：

1. 假设对于小于n的参数都成立
2. 证明n也成立，如：

T(n)=2T(n/2)+n≤2cn2log⁡n2+n=cnlog⁡n2−c′n+n≤cnlog⁡n(c≥1)

#### 递归树

用不上

如果一定要用就点了吧

#### 主定理

有式子T(n)=aT(nb)+f(n)，其中a>=1,b>1

根据nlogb⁡a与f(n)的大小关系分以下3种情况：

1. f(n)=Ω(nlogb⁡a−ϵ)，其中ϵ>0

表明f(n)的影响力不如递归

T(n)=Θ(nlogb⁡a)

1. f(n)=Θ(nlogb⁡alogϵ⁡n)，其中ϵ≥0

注意n的次方没有减去ϵ，表明同级（但不完全同）。ϵ可以为0表明log项可以没有

T(n)=Θ(nlogb⁡alogϵ+1⁡n)

1. f(n)=Ω(nlogb⁡a+ϵ)，其中ϵ>0，并且存在c<1,n→∞,af(nb)≤cf(n)

后面那个条件不知道什么意思，反正考试也不会考没法用主定理的，所以直接忽视

f(n)占支配地位

T(n)=Θ(f(n))

## 蛮力算法

憨憨查找、选择排序、插入排序

~~狗都会~~

## 分治 in 排序

### 快速排序

```
Func Partition(A[], low, high)
	pivot = A[low]
	while low < high:
		while low < high && A[high] >= pivot:
			high--
		A[low] = A[high]
		while low < high && A[low] <= pivot:
			low++
		A[high] = A[low]
	A[low] = pivot
	return low

Func QuickSort(A[], low, high)
	if low < high:
		pivot = Partition(A, low, high)
		QuickSort(A, low, pivot - 1)
		QuickSort(A, pivot + 1, high)
```

### 归并排序

W(n)=2W(n2)+O(n)

#### 决策树

引入决策树，说明算法结果需要一步一步走到叶节点，从而证明，比较排序的最坏情况时间复杂度的下界： $$ \Omega(n\log n) $$

#### 逆序对及计数

计算逆序对数，可以在归并排序中顺便完成

```
long long merge_count(long long array[], long long start, long long end)
{
	if (start == end)
		return 0;
	long long mid = (start + end) / 2;
	long long lcount = merge_count(array, start, mid);
	long long rcount = merge_count(array, mid + 1, end);
	long long p1 = mid, p2 = end;
	long long* copyarray = new long long[end - start + 1];
	long long copy_index = end - start;
	long long count = 0;
	while (p1 >= start and p2 >= mid + 1)
		if (array[p1] > array[p2])
			count += p2 - mid, copyarray[copy_index--] = array[p1--];
		else
			copyarray[copy_index--] = array[p2--];
	while (p1 >= start)
		copyarray[copy_index--] = array[p1--];
	while(p2 >= mid+1)
		copyarray[copy_index--] = array[p2--];
	for (long long i = 0; i < end - start + 1; i++)
		array[start + i] = copyarray[i];
	return lcount + rcount + count;
}
```

## 分治例子

### 整数乘法

长度都为n的xy相乘，直接计算复杂度为O(n2) $$ x=x_1\cdot 2^{n/2}+x_0,y=y_1\cdot 2^{n/2}+y_0\ $$ 那么计算变为： $$ \begin{aligned} xy&=(x_1\cdot 2^{n/2}+x_0)(y_1\cdot 2^{n/2}+y_0)\ &=x_1y_1\cdot 2^n+(x_1y_0+x_0y_1)\cdot 2^{n/2}+x_0y_0\ &=x_1y_1\cdot 2^n+[(x_1+x_0)(y_1+y_0)-x_1y_1-x_0y_0]+x_0y_0 \end{aligned} $$ 将问题分解为x1y1 (x1+x0)(y1+y0) x0y0三个子问题 $$ W(n)\le3W(\frac{n}{2})+O(n) $$ 不知道为什么是小于等于

根据主定理 $$ W(n)=O(n^{\log_2 3}) $$

### 检测异类

期中考过

列出所有情况组合，每次都只做降低规模至一半的操作 $$ W(n)\le \frac{n}{2}+\frac{n}{2^2}+\cdots\ W(n)=O(n) $$

## $O(\log)$时间算法

### 二分查找

有序下二分查找、峰值查找、N计算

~~狗都会~~

### 红黑树

红黑树性质如下：

- 节点颜色只有红色或黑色
- 根节点必黑，叶节点必黑
- 节点若有子节点，必有2子；或者节点完全无子节点
- 红色节点不能连续出现
- 所有外部节点的黑色深度（到根路径上除根的黑色节点数）相等，称为黑色高度

准红黑树即根节点是红色，但其他性质都满足

**不存在ARB0**

对于h≥1，红黑树RBh左右子树分别为RBh−1或ARBh

对于h≥1，准红黑树ARBh左右子树都为RBh−1

**假设T为一个有n个内部节点的红黑树，则红黑树的普通高度不超过2log⁡(n+1)，基于红黑树的查找代价为O(log⁡n)**

## $O(n)$线性选择k阶元素

> 想要找到阶为k的元素，最笨的方法是每次O(n)找最小（或最大）并取出，找k次即可，用时O(kn)

### 期望情况

期望下，使用快速排序的Partition每次规模减半，可在O(n)内找到

```
Func Partition(A[], low, high)
	pivot = A[low]
	while low < high:
		while low < high && A[high] >= pivot:
			high--
		A[low] = A[high]
		while low < high && A[low] <= pivot:
			low++
		A[high] = A[low]
	A[low] = pivot
	return low
```

一顿期望的数学计算后，反正是O(n)

### 最坏情况

考虑最坏情况，每次都精准地选出最小或最大数作为基准，那么每次规模只−1，那么T(n)=T(n−1)+O(n)，退化成O(n2)

通过将数据分组，用选出基准**组**的方式来避免过于不平衡。已知，5个一组最好（期中考过，必不可能再考）

算法SELECT-WLINEAR：

1. 所有元素分5组，凑不齐一组的元素暂放（也可按课本的分为一组）
2. 找出每组中位数，共⌊n5⌋个
3. 对这⌊n5⌋个中位数递归地使用SELECT-WLINEAR找出其中的中位数m∗（同时调整好了组的位置）
4. 基于m∗的大小对所有元素（含第1步凑不齐一组的元素）进行划分，假设有x−1个元素小于m∗
5. 若k=x，返回m∗；若，对小于m∗的元素调用SELECT-WLINEAR找阶为k的元素；若k>x，对大于m∗的元素调用SELECT-WLINEAR找阶为k−x的元素

W(n)≤W(⌈n5⌉)+W(710n+6)+O(n)

第1项是找组中的中位数的中位数

第2项是划分结果。在所有⌈n5⌉组中，至少有一半的小组要贡献3个比m∗大的元素，其中不包括m∗所在组以及最后凑不满的组，那么至少也淘汰掉3(12⌈n5⌉−2)≥3n10−6个元素，子问题最大也不过n−(3n10−6)=710n+6

第3项是杂七杂八的用时

## DFS

### DFS树

- 树边Tree edge
- 回边Back edge
- 子嗣边Descendant edge
- 跨边Cross edge

有向图4种边都有

**无向图没有Cross edge**，证明如下：

> 反设遍历点u时，发现一条边指向v，uv是CE（即u与v无祖先后继关系）
>
> 首先，v不是白色，否则uv是TE；v不是灰色，否则u与v有祖先后继关系，uv是BE；那么v应该是黑色。
>
> 那么，v在u访问前已完成访问，即访问v时u尚未访问，那么vu应为TE（无向图），u与v有祖先后继关系，与假设矛盾

### 活动区间

在遍历过程中，一个节点的活动区间定义为从该节点被发现到遍历结束的时间区间： $$ active(v)=[discoverTime, finishTime] $$ 与DFS树相关有以下定理： $$ \begin{aligned} \text{u是v在DFS树中的后继节点 iff }&active(u)\subseteq active(v)\ \text{u和v没有祖先后继关系 iff }&active(u)\text{ 和 }active(v)\text{ 没有重叠}\ \text{uv是TE iff }&active(v)\subset active(u)\and \text{不存在第3个点x，使得 }active(v)\subset active(x)\subset active(u)\ \text{uv是DE iff }&active(v)\subset active(u)\and \text{存在第3个点x，使得 }active(v)\subset active(x)\subset active(u)\ \text{uv是BE iff }&active(u)\subset active(v)\ \text{uv是CE iff }&active(v)\text{ 在 }active(u)\text{ 前面} \end{aligned} $$

### 拓扑排序

- 无向图无拓扑序
- 有向图如有环，则不存在拓扑序
- 有向无环图必存在拓扑序

```
func Topo(Graph G)
	while G 非空:
        找到当前G中任一入度为0的点x
        x加入拓扑序列
        从G中删除x
```

### 关键路径

任务之间的依赖关系可以用有向图G表示，任务对应点，边i→j表示ai依赖于aj

定义每个任务的最早开始时间earlist start time，记为esti

每个任务的esti和时长li唯一地确定了任务的最早结束时间earlist finish time，记为efti=esti+li

- 不依赖任何其他任务的任务esti=0
- 依赖于若干其他任务的任务，其esti为依赖任务中eftj的最大值，esti=maxefti|ai→aj
- 任何任务的esti确定后，efti=esti+li

关键路径是一组任务v0,v1,⋯,vk，满足：

- v0没有任何依赖
- 对任意1≤i≤k：vi→vi−1,esti=efti−1
- 任务vk的eftk是所有任务的eft的最大值

```
func CRITICAL-PATH(v)
	v染成灰色
	v.est = 极小值
	v的关键依赖设为空
	for v的每一个邻居w :
		if w是白色：
			CRITICAL-PATH(w)
			if w.eft >= v.est:
				v.est = w.eft
				v的关键依赖设为w
		else if w.eft >= v.est:
			v.est = w.eft
			v的关键依赖设为w
	v.eft = v.est + v.l
	v染成黑色
```

有点点类似tarjan

### 强连通分量 in 有向图

给每个节点一个DFS标号v.index，以时间戳表示访问顺序；给每个节点一个追溯值v.lowlink，表示从v出发可达的节点的最小的index $$ v\text{是强连通分量的根 iff }v.index=v.lowlink $$

```
输入图G=(V,E)
index = 0
S初始化为空栈

for each i in V:
	if i未访问过:
		strongconnect(i)

func strongconnect(v)
	v.index = v.lowlink = index
	index++
	v入栈S
	
	for each(v,w) in E:
		if w未访问过:
			strongconnect(w)
			v.lowlink = min(v.lowlink, w.lowlink)
		else if w在栈S中:
			v.lowlink = min(v.lowlink, w.index)
	
	if v.index == v.lowlink:
		栈S栈顶元素不断出栈直到v出栈，本次出栈的元素为一强连通分量
```

需要一个栈来留存访问状态以生成强连通分量

每个节点调用一次`strongconnect`，每条边最多一次访问，判断元素在栈中用标记保存每次用时O(1)，总计时间复杂度O(n+m)

### 割点 in 无向图

割去这个点，使得新图不再连通

tarjan即可

若一个节点v有至少一个子节点w使得w.lowlink≥v.index说明w无法回到v的祖先，即v是割点

对于根节点（DFS入口），根节点是割点当且仅当根节点的子树数量大于1

```
输入图G=(V,E)
index = 0

for each i in V:
	if i未访问过:
		标记i为根节点
		strongconnect(i)

func strongconnect(v)
	v.index = v.lowlink = index
	index++
	
	for each(v,w) in E:
		if w未访问过:
			strongconnect(w)
			if v是根节点:
				v的子树数量++
			else if w.lowlink >= v.index:
				v是割点
		v.lowlink = min(v.lowlink, w.index)
	
	if v是根节点且v的子树数量超过1:
        v是割点
```

### 割边 in 无向图

割去此边，新图不再连通

一条边是割边，即要求（DFS树中）孩子节点无法回溯到父亲节点（更无法向上回溯） $$ \text{边uv，u是父亲，v是孩子}\ \text{uv是割边 iff }v.lowlink>u.index $$ 此处要求严格大于，即连父亲都回溯不到

```
输入图G=(V,E)
index = 0

for each i in V:
	if i未访问过:
		strongconnect(i)

func strongconnect(v)
	v.index = v.lowlink = index
	index++
	
	for each(v,w) in E:
		if w为v父亲:
			continue
		if w未访问过:
			标记v是w的父亲
			strongconnect(w)
			v.lowlink = min(v.lowlink, w.index)
			if w.lowlink > v.index:
				(v,w)是割边
		else:
			v.lowlink = min(v.lowlink, w.index)
```

只有w未访问过（w是v孩子节点）才判断lowlink>index

## BFS

### BFS树

- TE：有
- BE：有向图可以有，无向图没有

证明无向图没有BE：

> 假设(u,v)是BE，v是u的祖先
>
> 若v是白色，与v是u的祖先矛盾；
>
> 若v是灰色，与v是u的祖先矛盾；
>
> 若v是黑色，v应在变黑前将u入队，(u,v)应为TE，与(u,v)是BE矛盾
>
> 综上，无向图没有BE

- DE：不存在

用有向图证明，无向图同理：

> 反设uv是DE，u是v的祖先且不是v的父亲（若u是v的父亲，uv应为TE）
>
> 考虑u刚出队、即将处理邻居的时刻：
>
> 若v是白色，uv是TE，与uv是DE矛盾
>
> 若v是灰色或黑色，v比u先出队，与u是v的祖先矛盾
>
> 综上，不存在DE

- CE：有

有向图中，若有CE记为x→y，则y.dis≤x.dis+1。y最多在x的下一层（要求在同一棵BFS树上）

无向图中，若有CE记为(x,y)，则y.dis=x.dis\ory.dis=x.dis+1。y和x在同一层或下一层（要求在同一颗BFS树上）

### 二分图

太简单

### 寻找$k$度子图

以为是多厉害算法，就是用个队列把不够k的节点放进去排队tck罢了

```
func k-degree-subgraph(G, k)
	初始化空队列Q
	for each v in V:
		if v.degree < k:
			v入队列Q
	while 队列Q非空:
		v = 队列Q出队首
		for each (v,w) in E:
			w.degree--
			if w.degress < k && w不在队列Q中:
				w入队列Q
		从G中删除v
	G即为k度子图
```

## 最小生成树

### Prim

贪心地构建最小生成树

每次都从不在当前最小生成树的节点中选出一个节点，它有一条边使得它和最小生成树内一点相邻且此边权值最小

```
func Prim
	初始化空图MST
	初始化空优先队列Q
	初始化candidateEdge为空
	s入Q
	while Q非空:
		v = Q取队头
		if v在MST中:
			continue
		candidateEdge[v]加入MST
		for each v->w in E:
			if candidateEdge[w]为空 || candidateEdge[w] > v->w权值:
				candidateEdge[w] = v->w
				w入Q
```

对于每个点，都要进出队列Q；对于每条边，都要被确认一次代价 $$ T(n,m)=O(n\cdot C_{EXTRACT-MIN}+n\cdot C_{INSERT}+m\cdot C_{DECREASE-KEY}) $$

| 操作         | 数组 | 堆      |
| ------------ | ---- | ------- |
| INSERT       | O(1) | O(log⁡n) |
| EXTRACT-MIN  | O(n) | O(log⁡n) |
| DECREASE-KEY | O(1) | O(log⁡n) |

- 数组实现优先队列：O(n⋅n+n⋅1+m⋅1)=O(n2+m)
- 堆实现优先队列：O(n⋅log⁡n+n⋅log⁡n+m⋅log⁡n)=O((n+m)log⁡n)

### Kruskal

Kruskal先将所有边排序，再逐条尝试是否加入MST（中间过程很可能不连通）

```
Func Kruskal
	对M中的边按权值从小到大排序
	for each (u,v) in M:
		if MST中点数 == n:
			break
		if find(u) != find(v):
			(u,v)加入MST
			union(u,v)
```

将边排序，用时O(mlog⁡m)

对每条边，可能都要调用1次find和union，用时O(n+mlog⁡n)=O(mlog⁡m)

只要并查集实现得较为高效，总代价由边排序支配：O(mlog⁡m)=O(mlog⁡n)

### Minimum-weight Cut-crossing Edge

跨越切的最小权值边

> 切：图G=(V,E)有两点集V1V2满足V1∪V2=V,V1∩V2=\empty，V1V2构成一个切

- 如果存在一个切使得某边e成为该切的MCE，则e一定属于某最小生成树

证明：

> 反设，e不属于任何最小生成树
>
> 考虑某个最小生成树T，它必然存在一条跨越切的边，记为e′
>
> 将e加入T成环。因为T是最小生成树，所以e是环上权值最大的边之一，即e.weight≥e′.weight
>
> 又因为e是MCE，所以e.weight≤e′.weight
>
> 所以，e.weight=e′.weight
>
> 将e′从T中去除并加入e得到T′，则T′是最小生成树，与e不属于任何最小生成树矛盾

## 最短路径

### Dijkstra 单源非负

类似Prim，每次都从候选点中选择最近的加入最短路径树

**无法处理非负边权**

```
func Dijkstra(G, s)
	初始化空优先队列Q
	for each i from 1 to n:
		dis[i] = MAX
	dis[s] = 0
	for each (s,i) in E:
		i进Q
		i前驱记为s
	while Q非空:
		x = Q取队首
		for each (x,i) in E:
			if dis[x] + xi.weight < dis[i]:
				dis[i] = dis[x] + xi.weight
				i前驱记为x
				if i不在Q中:
					i进Q
```

对于每个点，都要进出队列Q；对于每条边，都要被确认一次代价 $$ T(n,m)=O(n\cdot C_{EXTRACT-MIN}+n\cdot C_{INSERT}+m\cdot C_{DECREASE-KEY}) $$

| 操作         | 数组 | 堆      |
| ------------ | ---- | ------- |
| INSERT       | O(1) | O(log⁡n) |
| EXTRACT-MIN  | O(n) | O(log⁡n) |
| DECREASE-KEY | O(1) | O(log⁡n) |

- 数组实现优先队列：O(n⋅n+n⋅1+m⋅1)=O(n2+m)
- 堆实现优先队列：O(n⋅log⁡n+n⋅log⁡n+m⋅log⁡n)=O((n+m)log⁡n)

### Floyd-Warshall 多源无负环

算法利用不断地计算传递闭包

Dij(k)表示i到j的只利用x进行中转的最短路径i→x+x→j,1≤x≤k，其中x不超过k

```
Func Floyd-Warshall(G)
	for each i from 1 to n:
		for each j from 1 to n:
			D[i][j] = MAX
	for each i from 1 to n:
		D[i][i] = 0
	for each (i,j) in E:
		D[i][j] = D[j][i] = ij.weight
	for k from 1 to n:
		for i from 1 to n:
			for j from 1 to n:
				if D[i][k] + D[k][j] < D[i][j]:
					D[i][j] = D[i][k] + D[k][j]
					Go[i][j] = Go[i][k]//记录路径
	return D
```

`Go[i][j] = x`表示i到j最短路上i后的下一个节点，递归地访问`Go[x][j]`即得下一跳

### Bellman-Ford 单源 负环检查

算法无脑进行n−1次所有边尝试松弛。每次不断增加已算出最短路径的点的数量。算法在第n次判断是否仍然能松弛，若能则有负环

```
Func Bellman-Ford(G, s)
	for each i from 1 to n:
		dis[x] = MAX
	dis[s] = 0
	for i from 1 to n - 1:
		relax = False
		for each (u,v) in E:
			if dis[u] + uv.weight < dis[v]:
				dis[v] = dis[u] + uv.weight
				v的前驱记为u
				relax = True
		if relax == False:
			break
	for each (u,v) in E:
		if dis[u] + uv.weight < dis[v]:
			存在负环，退出
	return dis
```

算法最多需要遍历n轮所有m条边，复杂度O(nm)

## 贪心

### 相容任务调度

记输入的任务集合为A=a1,a2,⋯,an，每个任务定义为区间ai=[si,fi)，si和fi分别为任务的开始和结束时间。找出A中最大（包含任务个数最多）的相容任务集。

**任务之间没有价值区别，只追求数量最大**

正解：“最早结束任务”。将所有任务按照结束时间的先后进行排序，然后从前往后依次扫描所有任务。如果一个任务不和已选择的任务冲突，则选择它；否则忽略。

```
func COMPATIBLE-TASKS(A)
	sort A accordint to Fi
	Compatible = empty()
	while A != empty:
		选出a0
		将与a0冲突的任务从A中删除
		a0加入Compatible
	return Compatible
```

#### 正确性证明（贪心代表）

假设COMPATIBLE-TASKS选出的任务列表为C=i1,i2,⋯,ik，任务顺序为被算法选出的顺序即时间顺序

假设存在一个问题的最优算法得到任务集合O=j1,j2,⋯,jm，任务顺序为时间顺序

- 证明：k=m，即COMPATIBLE-TASKS总选出和最优解一样大的任务集合（不一定完全一致）

下面归纳证明“令f(a)表示任务a的结束时间，有r≤k,f(ir)≤f(jr)”：

当r=1时，贪心算法选择全局结束最早的任务，显然f(i1)≤f(j1)，命题成立

假设r−1时，命题成立，f(ir−1)≤f(jr−1)，则

显然，ir−1和ir是相容的，jr−1和jr是相容的

则ir−1和jr一定相容，ir−1后jr可选

又因为贪心算法总是选择最早结束的任务，所以f(ir)≤f(jr)

当r时，命题成立。综上，得证

- 证明：COMPATIBLE-TASKS总能选出最大相容任务集合

反设m>k，那么O中至少有一个任务在jk后面，记为jk+1

由上得，f(ik)≤f(jk)，所以ik与jk+1相容

贪心算法未选择jk+1与算法内容矛盾，假设不成立

综上，得证

### Huffman Code

```
func HUFFMAN-ENCODING(A)
	初始化优先队列Q空
	for each a_i in A:
		<a_i,f(a_i)>入Q
	while Q内元素个数大于1:
		i = Q取队首
		j = Q取队首
		新建节点a_k,左子树为i，右子树为j
		f(a_k) = f(i) + f(j)
		<a_k,f(a_k)>入Q
```

用时瓶颈在于优先队列Q取最小时：

O(n2)：数组实现

O(nlog⁡n)：堆实现

## 简单数据结构

### 堆

- 堆结构特性：比完美二叉树在底层少若干节点，且底层左侧连续排列
- 堆偏序特性：根节点的值大于所有子节点的值（大根堆）

#### 堆的修复

取出堆顶后，左右子树仍满足两性质。先恢复堆结构特性，再恢复堆偏序特性：

1. 底层最右侧的元素移至堆顶（堆结构fixed）
2. 从堆节点开始递归地，将父亲节点与两子节点中大者交换，直到叶子节点（堆偏序fixed）

修复次数不超过堆高度为O(log⁡n)，每次代价为O(1)，堆修复代价为O(log⁡n)

#### 堆的构建

1. 将元素摆放在堆中
2. 从叶子节点开始，子节点中的最大值若大于父亲节点则与父亲节点交换，并从该子节点位置开始向下修复堆

W(n)=2W(n2)+2log⁡nW(n)=O(nlog2⁡2)=O(n)

#### 堆排序

基于大根堆进行升序排序

堆顶与底层最右侧的叶子交换后，堆大小-1使原堆顶不在堆的处理范围；反复进行直到堆大小为0

```
func HEAP-SORT(A)
	A建堆
	for i from 1 to n:
		swap(A[1], A[n+1-i])
		堆A大小--
		FIX-HEAP(1)
```

#### 优先队列

增加了INSERT插入和EDIT-KEY改权操作

- INSERT：新增叶子节点（从左到右），堆增大，新节点向上上浮同时向下修复
- EDIT-KEY：直接修改权值，向上上浮同时向下修复

### 并查集

变化的、扩增的等价关系，即**动态等价关系**

- FIND(a_i)：返回a_i所在的**等价类的代表元**
- UNION(a_i,a_j)：将a_i和a_j所在的等价类合并成一个等价类

#### 普通并+普通查

慢

O(nl)

#### 加权并+普通查

feature: **WEIGHTED-UNION**

把节点数更少的挂到更多的上，需要在根节点记录根树的大小信息

- 基于WEIGHTED-UNION的并查集，k个节点的树高不超过⌊log⁡k⌋，证明：

k=1时显然成立

假设对任意，m个节点的树高不超过⌊log⁡m⌋

假设有k个节点的树T是由k1个节点的子树T1和k2个节点的子树T2合并而成的，不妨设k1≥k2

此时T树高h=maxh1,h2+1

而h1≤⌊log⁡k1⌋≤⌊log⁡k⌋且k2≤k2,h2+1≤⌊log⁡k2⌋+1≤⌊log⁡k2⌋+1=⌊log⁡k⌋

综上，h≤⌊log⁡k⌋

- 采用WEIGHTED-UNION和FIND的并查集，最坏代价为O(n+llog⁡n)

树高不超过log⁡n，那么FIND代价不超过O(llog⁡n)

初始化，需要O(n)

WEIGHTED-UNION代价不超O(n)

所以n个节点长度为l的并查集程序代价为O(n+llog⁡n)

#### 加权并+路径压缩

在C-FIND找到祖先节点后，立即更新沿途的节点的父亲为该祖先

- 最坏情况时间复杂度为O((n+l)log∗⁡n)≈O(n+l)

### 哈希表

哈希表实现了接近下界O(1)的准常数时间性能O(1+α)

定义**负载因子**α=nm，它反映了哈希表的拥挤程度

#### 直接寻址表

键值空间U为每个元素分配了空间，查找每个元素用时O(1)但空间开销惊人

#### 简单均匀哈希

多用h(k)=kmodn等函数

##### 封闭寻址

又叫链式寻址

在哈希表的每个位置放的是指向一个链表头部的指针

**冲突元素会直接插入到链表头部而不是尾部**，以实现O(1)的插入

一次成功查找，代价为O(1)

一次不成功查找，平均代价为Θ(1+α)。不成功查找的比较次数为找到链表尾所用次数。

##### 开放寻址

i都是从0开始

- 线性探测：直接往后一个个挪看有没有位置

h(k,i)=(h′(k)+i)modm

- 二次探测：第i次从+12,−12,+22,−22,+32,−32,⋯,+n2,−n2里选第i项加上（不是累加）

h(k,i)=(h′(k)+c1i+c2i2)modm

- 双重哈希：如果冲突，两个函数一起算

h(k,i)=(h1(k)+ih2(k))modm

假设α=nm<1：

- 不成功查找的平均代价不超过11−α
- 成功查找的平均代价不超过1αln⁡11−α

## 动态规划

### 矩阵链相乘

枚举low（从大到小）、high（从low+1递增），在每一组(low,high)中枚举中间的k（此过程能用到前面计算好的），在O(n3)内解

```
func MATRIX-MULTI-DP(Dimelist[1...n])
	for low from n-1 to 1:
		for high from low+1 to n:
			if high-low == 1:
				bestcost = 1
				bestlast = -1//记录分割位置
			else
				bestcost = MAX
			for k from low+1 to high-1:
				a = cost[low][k]
				b = cost[k][high]
				c = multCost(Dimelist[low], Dimelist[k], Dimelist[high])
				if a+b+c < bestcost:
					bestcost = a+b+c
					bestlast = k
			cost[low][high] = bestcost
			last[low][high] = bestlast

func EXTRACT(low, high)
	if high - low > 1:
		k = last[low][high]
		EXTRACT(low, k)
		EXTRACE(k, high)
		k进输出队列
```

### 编辑距离

将一个单词变成另一个单词所需最少“编辑操作“次数：插入、删除、替换。

考虑`dp[i][j]`：

- 插入，直接加上`B[j]`，从`dp[i][j-1] + 1`递推而来
- 删除，直接删掉`A[i]`，从`dp[i-1][j] + 1`递推而来
- 替换，判断是否一致，从`dp[i-1][j-1]`递推而来

```
dp[i][j] = min(dp[i-1][j] + 1, dp[i][j-1] + 1)
if A[i] == B[j]:
	dp[i][j] = min(dp[i][j], dp[i-1][j-1])
else:
	dp[i][j] = min(dp[i][j], dp[i-1][j-1] + 1)
```

### 背包问题

#### 01背包

每件物品只能装0件或1件

```
func 01packet(w[1...n], v[1...n], C)
	dp[0...C] = 0
	for i from 1 to n:
		for j from C to w[i]:
			dp[j] = max(dp[j], dp[j-w[i]] + v[i])
	return dp[C]
```

如果使用`dp[i][j]`表示状态，则表示把1⋯i这些物品都考虑后，大小j下所能取得的最大价值

但是实际上我们最后只关心`dp[n][C]`，所以将二维dp压缩至一维，那么**j的循环必须从大到小，以免重复拿某物品（完全背包）**

i的循环顺序无所谓，保证遍历即可

#### 分组背包

有很多组，**每组中只能选0/1件**

相当于把每1组当成01背包中的每1个物品。不可以利用同组的物品进行状态转移，所以起码要维护两个`dp[1...C]`，其中`C`为容量。

可以退化空间复杂度至O(nm)，也可以用滚动数组实现O(2m)，其中m为最大容量

```
func groupedPacket(w[1...n][1...], v[1...n][1...], C)
	dp[...][...] = 0
	for i from 1 to n:
		for j as item in Group[i]:
			for k from C to w[i][j]:
				dp[i][k] = max(dp[i][k], dp[i-1][k-w[i][j]] + v[i][j])
	return dp[n][C]
```

#### 完全背包

每件物品能装0件或**任意数量**件

```
func allpacket(w[1...n], v[1...n], C)
	dp[0...C] = 0
	for i from 1 to n:
		for j from w[i] to C:
			dp[j] = max(dp[j], dp[j-w[i]] + v[i])
	return dp[C]
```

i的循环顺序仍然无所谓

**j的循环必须从小到大，这样大容量才可以从（同一物品的）小容量转移而来，即实现重复拿取**

#### 多重背包

每件物品能装0件或**指定上限**件

```
func mulpacket(w[1...n], v[1...n], s[1...n], C)
	dp[0...C] = 0
	for i from 1 to n:
		for j from C to w[i]:
			for k from 1 to s[i] && w[i] * k <= j:
				dp[j] = max(dp[j], dp[j - w[i] * k] + v[i] * k)
```

大致和01背包相同，只是01背包中考虑i这单个物品的过程被扩展为判断1个i、2个i、...、s[i]个i这堆物品。所以也有方法直接把物品复制s[i]个直接转变为01背包

仍然要注意j的循环从大到小，本次更新的值不会在同一个i循环里被用上

### 硬币兑换问题

类似完全背包。最外层循环是最新参与考虑的硬币，次层循环是从小到大的金额枚举

### 最大和连续子序列

`dp[i]`表示`i`在末尾的连续子序列的和的最大值

全局答案应该是ans=maxdp[1],⋯,dp[n]

考虑每一个数，它只有2种情况：

- 接上前一位。`dp[i] = dp[i-1] + a[i]`
- 自己新起一串。`dp[i] = a[i]`

得状态转移方程dp[i]=max(dp[i−1]+a[i],a[i])

### 相容任务调度

整个不懂课本在说什么

反正就是递归吧

## 平摊分析

Cactual实际代价，直接、精准地反映了每次的代价

Caccounting记账代价，让一些操作产生的额外的代价（正）以抵消另外一些操作的代价（负的代价）

Camortized=Cact+Caccounting平摊代价

运行花费较低的operations时先存credit未雨绸缪, 供未来花费较高的operations使用

**设置每个操作的平摊成本(amortized cost)后，要做valid check确保任何时刻credit不可以是0**

具体看书

## 对手论证

将算法设计者与算法分析者看作对手，同时扮演两个角色进行算法分析。

1. 算法设计者：尽量多的创造更多信息
2. 算法分析者：尽量少的给予信息，拥有着**随时合理改变取值**的能力

具体看书

## N NP NP-hard NP-complete

> 优化问题：优化问题关注某种特殊的结构，希望优化该结构的某种指标
>
> 判定问题：不再关注指标的最大/最小值，而是引入参数k，并回答一个“是或否”的问题：本结构的指标与参数k是否满足某种关系

- P问题：如果存在关于n的多项式poly(n)使得存在一个**解决问题**的算法的代价f(n)=O(poly(n))

证明P问题：找到多项式时间的解决问题的算法即可

- NP问题：如果存在关于n的多项式poly(n)使得存在一个**验证问题**的算法的代价f(n)=O(poly(n))，**不要求解决**

证明NP问题：找到多项式时间的验证问题的算法即可

> 归约 reduction
>
> 问题P可以归约到问题Q（P is reducible to Q）的含义是解决问题P可以间接地通过解决问题Q来实现
>
> 判定P到Q的归约为一个函数T(x)满足：
>
> - 将P的任一合法输入x转换成Q的任一合法T(x)
> - PQ的输出保持一致（一荣俱荣，一损俱损）
>
> 需要证明Q的输出一定就是P的输出
>
> 如果T是多项式的，那么P多项式时间归约到Q，记为P≤PQ（符号旁边的P表示poly多项式）
>
> 符号也表明，Q难度高于P

- NP-hard问题：比所有的NP问题都难（它自己不需要是NP问题），∀Q∈NP,Q≤PP

证明NP-hard问题：课本没教

- NP-complete问题：是NP问题的NP-hard问题

证明NP-complete问题：

1. 欲证问题Q是NP完全问题
2. 找来一个已知的NP完全问题 P ，构造P≤PQ，由传递性，Q比所有NP问题都难了，Q是NP难问题
3. 证明Q是NP问题
4. 综上，得证

<details class="details-reset details-overlay details-overlay-dark" id="jumpto-line-details-dialog" style="box-sizing: border-box; display: block;"><summary data-hotkey="l" aria-label="Jump to line" role="button" style="box-sizing: border-box; display: list-item; cursor: pointer; transition: color 80ms cubic-bezier(0.33, 1, 0.68, 1) 0s, background-color, box-shadow, border-color; list-style: none;"></summary></details>

- © 2022 GitHub, Inc.

- [Terms](https://docs.github.com/en/github/site-policy/github-terms-of-service)
- [Privacy](https://docs.github.com/en/github/site-policy/github-privacy-statement)
- [Security](https://github.com/security)
- [Status](https://www.githubstatus.com/)
- [Docs](https://docs.github.com/)
- [Contact GitHub](https://support.github.com/?tags=dotcom-footer)
- [Pricing](https://github.com/pricing)
- [API](https://docs.github.com/)
- [Training](https://services.github.com/)
- [Blog](https://github.blog/)
- [About](https://github.com/about)

Loading complete